<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" minWidth="400" 
			   minHeight="400" xmlns:component="ro.calin.component.*" 
			   xmlns:model="ro.calin.component.model.*" xmlns:appmodel="ro.calin.app.model.*" xmlns:utils="ro.calin.utils.*"
			   backgroundColor="black">
	<fx:Script>
		<![CDATA[
			import mx.collections.IList;
			import mx.controls.Alert;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.utils.ObjectUtil;
			
			import ro.calin.app.model.Config;
			import ro.calin.app.model.TextModel;
			import ro.calin.component.event.CategoryEvent;
			import ro.calin.component.event.MenuEvent;
			import ro.calin.component.model.CategoryViewerModel;
			import ro.calin.component.model.MenuEntryModel;
			import ro.calin.component.model.MenuModel;
			import ro.calin.component.model.PictureModel;
			import ro.calin.component.model.PictureViewerModel;
			import ro.calin.component.model.SubcategoryModel;
			import ro.calin.utils.SWFProfiler;
			import ro.calin.utils.XmlToObjectConverter;
			
			import spark.components.Label;
			import spark.effects.Fade;
			
			/**
			 * Name of special pictureset which contains 
			 * references to pictures to be shown when not on gallery.
			 */
			private static const WALLPAPERS:String = "WALLPAPERS";
			
			private static const MENU_ACTION_CLICK:String = "click";
			private static const MENU_ACTION_HOVER:String = "hover";
			
			private static const MENU_ACTION_SLIDE:String = "slide";
			private static const MENU_ACTION_SLIDE_UP:String = "up";
			private static const MENU_ACTION_SLIDE_DOWN:String = "down";
			private static const MENU_ACTION_SLIDE_MIDDLE:String = "middle";
			
			private static const MENU_ACTION_CATEG:String = "categ";
			private static const MENU_ACTION_URL:String = "url";
			private static const MENU_ACTION_TEXT:String = "text";
			
			/**
			 * Called when config xml is received.
			 * Populate config from that.
			 */ 
			protected function configService_resultHandler(event:ResultEvent):void
			{
				//populate the mappings
				var mappings:Dictionary = new Dictionary();
				mappings[Config] = {
					categories: ["Mapof", "key", CategoryViewerModel],
					picturesets: ["Mapof", "key", PictureViewerModel],
					textset: ["Mapof", "key", TextModel]
				};
				mappings[CategoryViewerModel] = {
					subcategories: ["Listof", SubcategoryModel]
				};
				mappings[MenuEntryModel] = {
					entries: ["Listof", MenuEntryModel],
					"aliases": {
						"action": "extra"
					}
				};
				mappings[MenuModel] = {
					entries: ["Listof", MenuEntryModel],
					"aliases": {
						"action": "extra"
					}
				};
				mappings[PictureViewerModel] = {
					pictures: ["Listof", PictureModel]
				};
				mappings[SubcategoryModel] = {
					"aliases": {
						"setref": "extra"
					}
				}
					
				var configXml:XML = XML(event.result);
				
				var converter:XmlToObjectConverter = new XmlToObjectConverter(mappings);
				
				converter.convertToObject(configXml, config);
				
				menu.model = config.menu;
				
				picViewer.registerModel(WALLPAPERS, config.picturesets[WALLPAPERS], true);
				picViewer.setActiveModel(WALLPAPERS);
				picViewer.slide(PictureViewer.DIR_DOWN ,PictureViewer.MODE_RAND);
			}
			
			private function toggleFullScreen():void {
				var newState:String;
				try {
					if (stage.displayState == StageDisplayState.FULL_SCREEN) {
						stage.displayState = StageDisplayState.NORMAL;
						fs.label = "Fullscreen";
					} else {
						stage.displayState = StageDisplayState.FULL_SCREEN;
						fs.label = "Windowed";
					}
				} catch (any:*) {
					//ignore
				}
			}
			
			private function addEventListeners():void {
				//hide when user move mouse away from category
				catViewer.addEventListener(MouseEvent.ROLL_OUT, function(event:MouseEvent):void {
					categoryFadeOut();
				});
				catViewer.addEventListener(MouseEvent.ROLL_OVER, function(event:MouseEvent):void{
					categoryFadeIn();
				});
				menu.addEventListener(MouseEvent.ROLL_OUT, function(event:MouseEvent):void {
					categoryFadeOut();
				});
				menu.logo.addEventListener(MouseEvent.ROLL_OVER, function(event:MouseEvent):void {
					categoryFadeOut();
				});
			}
			
			/**
			 * Called when error occured in getting conf xml.
			 * Show error popup.
			 */ 
			protected function configService_faultHandler(event:FaultEvent):void
			{
				Alert.show("Connection error. Contact admin at calin014@gmail.com.");
				trace(ObjectUtil.toString(event.fault));				
			}
			
			/**
			 * Processes a menu action that looks like this:
			 * action = [slide|categ|url|text:value]
			 * value = [up/down/middle|random_string]
			 * 
			 */
			protected function processMenuAction(action:Array, event:MenuEvent=null) : void {
				if(!action || action.length != 2) throw new Error('Bad action.');
				
				if(textDisplay.parent != null) removeElement(textDisplay);
				
				switch(action[0]) {
					case MENU_ACTION_SLIDE:
						switch(action[1]) {
							case MENU_ACTION_SLIDE_UP:
								picViewer.setActiveModel(WALLPAPERS);
								picViewer.slide(PictureViewer.DIR_UP, PictureViewer.MODE_RAND);
								currentState = "menuTop";
								break;
							case MENU_ACTION_SLIDE_DOWN:
								picViewer.setActiveModel(WALLPAPERS);
								picViewer.slide(PictureViewer.DIR_DOWN, PictureViewer.MODE_RAND);
								currentState = "menuBottom";
								break;
							case MENU_ACTION_SLIDE_MIDDLE:
								picViewer.setActiveModel(WALLPAPERS);
								if(currentState == "menuTop") {
									picViewer.slide(PictureViewer.DIR_DOWN, PictureViewer.MODE_RAND);
								} else {
									picViewer.slide(PictureViewer.DIR_UP, PictureViewer.MODE_RAND);
								}
								currentState = "menuMiddle";
								break;
						}
						break;
					case MENU_ACTION_CATEG:
						var xPos:Number = calculateMiddleButtonPosition(event.entry);
						if(event) showCategory(config.categories[action[1]], xPos);
						break;
					case MENU_ACTION_TEXT:
						//create a new one, otherwise the props would not get resetted
						textDisplay = new Label();
						
						var textModel:TextModel = config.textset[action[1]] as TextModel;
						//TODO: see here
//						setPictureViewerWallpaper(textModel.bgUrl);
						
						textDisplay.text = textModel.content;
						
						for (var prop:String in textModel.style) {
							try {
								if(textDisplay.hasOwnProperty(prop)) {
									textDisplay[prop] = textModel.style[prop];
								} else {
									textDisplay.setStyle(prop, textModel.style[prop]);
								}
							} catch(e:Error) {
								trace("Error applying style " + prop, e);
							}
						}
						
						addElement(textDisplay);
						
						break;
					case MENU_ACTION_URL:
						navigateToURL(new URLRequest(action[1]));
						break;
				}
			}
			
			private var cache:Dictionary = new Dictionary();
			private function calculateMiddleButtonPosition(entry:MenuEntryModel) : Number {
				// logo width + sum(i = [1, k - 1], i-th buttonwidth) + k-th buttonWith / 2
				
				var pos:Number = cache[entry];
				
				if(!pos) {
					pos = menu.logo.width + 5; //small adjustment ;))
				
					var i:int = 0;
					var entryList:IList = entry.containerEntries;
					var currentEntry:MenuEntryModel = entryList.getItemAt(i) as MenuEntryModel;
					
					while(currentEntry != entry) {
						//ugly!!!
						pos += menu.getButtonWidth(currentEntry);
						if(i + 1 == entryList.length) return -1;
						currentEntry = entryList.getItemAt(++i) as MenuEntryModel;
					}
					
					pos += menu.getButtonWidth(entry) / 2;
					
					cache[entry] = pos;
				}
				
				return pos;
			}
			
			//!!!!!!!!!!!!!!!!
			//TODO: fix categ view bug: remaining invisible(nothing to do with settimeout)
			//maybe z-index...it starts working again if another categ is selected
			//that implies changing model and x
			//steps to reproduce:
			//	1. move pointer very fast on the menu near a button for a big categ(w/ scroll)
			//  2. if the categ does not show it will continue to do so for the same button
			//  3. change to another button to have it work aganin
			
			protected function showCategory(model:CategoryViewerModel, x:Number /*, y:Number ?? bottom??*/):void {
				if(catViewer.model != model) {
					catViewer.model = model;
					
					//dimension and position
					//if more thumbs then the screen can fit, height is screen height
					//else, height is determined by nb of pics and pic height.
					//TODO: externalize hardcoded values
					catViewer.height = Math.min(this.height - menu.height, 
						catViewer.model.subcategories.length * 119);
					
					//center on menu button
					//TOOD: smfn not workin well if button not same width
					catViewer.x = x - catViewer.model.thumbWidth / 2;
				}
				
				//highlight all pics when moving on menu
				catViewer.highlighted = true;
				
				if(catViewer.model == model && catViewer.visible) {
					categoryFadeIn();
				} else {
					categoryFadeIn(true);
					if(catViewer.model == model) catViewer.scrollToBottom();
				}
			}
			
			private var isFadeIn:Boolean = false;
			private function categoryFadeOut():void {
				//no point fading out if it already fades out
				if(!isFadeIn) return;
				
				//revers it if it fades in, else, play it from begining
				if(categFadeAnimation.isPlaying)
					categFadeAnimation.reverse();
				else categFadeAnimation.play();
				
				isFadeIn = false;
			}
			
			private function categoryFadeIn(stop:Boolean = false):void {
				//no point fading in if it already fades in
				if(isFadeIn) return;
				
				//revers it if it fades out, else, play it from begining
				if(categFadeAnimation.isPlaying) {
					if(stop) {
						//stop it and play from begining(alpha = 0.0)
						//used when categ is changed(cuz we use the same component)
						categFadeAnimation.stop();
						categFadeAnimation.play(null, true);
					}
					// start stop de
					else categFadeAnimation.reverse();
				}	
				else categFadeAnimation.play(null, true);
				
				isFadeIn = true;
			}
			
			/**
			 * Called when item in menu is clicked or hovered.
			 * Depending if action type corresponds with event type, it does something or not.
			 * 
			 * action_type = [click|hover:slide|categ|url|text:value]
			 */
			protected function menu_itemHandler(event:MenuEvent):void
			{
				var action:* = (event.entry.extra as String);
				
				if(!action) return;
				
				action = action.split("//>");
				
				if((action[0] == MENU_ACTION_CLICK && event.type == MenuEvent.MENU_ITEM_CLICK) ||
					(action[0] == MENU_ACTION_HOVER && event.type == MenuEvent.MENU_ITEM_HOVER)) {
					(action as Array).shift();
					processMenuAction(action, event);
				}
			}
			
			/**
			 * Called when clicked on menu logo.
			 * Go back to menu state and randomize wallpaper.
			 */
			protected function menu_logoClickHandler(event:MenuEvent):void
			{
				var action:* = (config.menu.extra as String);
				
				if(!action) return;
				
				action = action.split("//>");
				(action as Array).shift();
				
				processMenuAction(action);
				
				catViewer.visible = false;
			}

			/**
			 * Called when clicked on subactegory.
			 * Hide category control and change picture viewer pics.
			 */
			protected function catViewer_categItemClickHandler(event:CategoryEvent):void
			{
				var picset:String = event.subcategory.extra as String;
//				picViewer.model = config.picturesets[picset];
				
				picViewer.registerModel("CURRENT_PICS", config.picturesets[picset], true);
				picViewer.setActiveModel("CURRENT_PICS");
				picViewer.slide(PictureViewer.DIR_UP, PictureViewer.MODE_FIRST);
				
				catViewer.visible = false;
			}
		
			/**
			 * Randomizes over wallpaper pictureset.
			 */
			
//			private function setPictureViewerWallpaper(url:String):void {
//				PictureModel(wallpaperModel.pictures[0]).url = url;
//				picViewer.slideDownOnModelChange = true;
//				picViewer.model = wallpaperModel;
//			}

		]]>
	</fx:Script>
	
	<s:states>
		<!--Menu is in the middle, random wallpaper.-->
		<s:State name="menuMiddle"/>
		
		<!--Menu is up.-->
		<s:State name="menuTop"/>
		
		<!--Menu is down. -->
		<s:State name="menuBottom"/>
	</s:states>
	
	<s:transitions>
		<s:Transition toState="*">
			<s:Move target="{menu}" duration="300"/>
		</s:Transition>
	</s:transitions>
	
	<fx:Declarations>
		<!-- This service requests the xml config. -->
		<s:HTTPService id="configService" url="config.xml" result="configService_resultHandler(event)"
					   fault="configService_faultHandler(event)" resultFormat="e4x"/>
		
		<!-- Store the model in memory. -->
		<appmodel:Config id="config" />
		
		<!-- Reference to a label used to display text -->
		<s:Label id="textDisplay" />
		
		<!-- Modified each time to contain only one pic, the current wallpaper. -->
		<model:PictureViewerModel id="wallpaperModel">
			<model:pictures>
				<fx:Array>
				</fx:Array>
			</model:pictures>
		</model:PictureViewerModel>
		
		<s:Fade id="categFadeAnimation" duration="1000" target="{catViewer}" alphaFrom="1.0" alphaTo="0.0"/>
	</fx:Declarations>
	
	<s:applicationComplete>
		<![CDATA[
			//TODO: use more often, find a way to remove on prod
			SWFProfiler.init(stage, this);
		
			//get the config xml
			configService.send();
		
			addEventListeners();
		]]>
	</s:applicationComplete>
	
	
	<!--This is the whole app(3 components): menu, picture viewer, category viewer-->
	<component:PictureViewer id="picViewer" width="100%" height="100%" />
	
	<component:Menu id="menu"
					itemClick="menu_itemHandler(event)" 
					itemHover="menu_itemHandler(event)"
					logoClick="menu_logoClickHandler(event)"
					width="100%" y.menuMiddle="{this.height * .7}" 
					y.menuTop="0" y.menuBottom="{this.height - menu.height}">
		<component:customComponent>
			<component:MenuButton click="toggleFullScreen();" height="{menu.height}" buttonMode="true" width="80">
				<component:entry>
					<model:MenuEntryModel id="fs" label="Fullscreen" color="0xECD672" fontSize="12" fontColor="0xbbbbbb" 
										   animToBottom="true"/>
				</component:entry>
			</component:MenuButton>
		</component:customComponent>
	</component:Menu>
	
	<component:CategoryViewer id="catViewer" alpha="0.0" bottom="{menu.height}"
							  categItemClick="catViewer_categItemClickHandler(event)" visible="{catViewer.alpha > 0.0}"/>
	
	<s:Button id="leftButton" skinClass="ro.calin.component.skin.PictureViewerButtonSkin" 
			  verticalCenter="0" left="-12" buttonMode="true" rotation="180"/>
	<s:Button id="rightButton" skinClass="ro.calin.component.skin.PictureViewerButtonSkin" 
			  verticalCenter="0" right="-12" buttonMode="true"/>
	
</s:Application>
